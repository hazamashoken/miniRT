/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   texture.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abossel <abossel@student.42bangkok.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/11 12:48:41 by abossel           #+#    #+#             */
/*   Updated: 2023/01/13 13:34:06 by abossel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
#include "raytrace.h"
#include "vector3.h"

/*
 * check if a point is on a black checkerboard square
 * only for shapes that have texture coordinates
 */
int	checkerboard_black(t_hit *h, float scale)
{
	if ((fmodf(h->u * scale, 1.0f) > 0.5f)
		^ (fmodf(h->v * scale, 1.0f) > 0.5f))
		return (1);
	return (0);
}

double	perlin(double x, double y, double z, int octaves)
{
    double	total;
    double	frequency;
    double	amplitude;
	double	persistence;
    double	max_value;
	int		i;

	total = 0.0;
	frequency = 1.0;
	amplitude = 1.0;
	persistence = 0.5;
	max_value = 0.0;
	i = 0;
    while (i < octaves)
	{
        total += noise(x * frequency, y * frequency, z * frequency) * amplitude;
        max_value += amplitude;
		amplitude *= persistence;
        frequency *= 2.0;
		i++;
    }
    return (total / max_value);
}

/*
 * map the perlin noise on a torus
 * c is the radius from centre to middle of tube
 * r is radius of the tube
 */
double	perlin_tiling(double x, double y, int octaves)
{
	double	c;
	double	a;
	double	xt;
	double	yt;
	double	zt;

	c = 2.0;
	a = 2.0;
	xt = (c + a * cos(2.0 * M_PI * y)) * cos(2.0 * M_PI * x);
	yt = (c + a * cos(2.0 * M_PI * y)) * sin(2.0 * M_PI * x);
	zt = a * sin(2.0 * M_PI * y);
	return (perlin(xt, yt, zt, octaves));
}

/*
 * returns the diffuse reflectance scale from the bump map
 */
float	bumpmap_reflect(t_hit *h)
{
	return ((perlin_tiling(h->u, h->v, 2) + 1.0f) / 2.0f);
}

/*
 * returns a bump generated by a perlin noise function
 * returns the noise dx, dy units away in a size x size map
 */
float	get_bump(t_hit *h, int size, int dx, int dy)
{
	float	map_u;
	float	map_v;
	int		map_x;
	int		map_y;

	map_x = h->u * size + dx;
	map_y = h->v * size + dy;
	while (map_x < 0)
		map_x += size;
	while (map_x >= size)
		map_x -= size;
	while (map_y < 0)
		map_y += size;
	while (map_y >= size)
		map_y -= size;
	map_u = (float)map_x / size;
	map_v = (float)map_y / size;
	return (perlin(map_u, map_v, 1.0, 8) + 0.5f);
}

/*
 * returns the bump map normal using a Sobel filter
 * assume a 512x512 pixel bump map
 * set scale to adjust height of bumps
 */
t_v3	bumpmap_normal(t_hit *h)
{
	t_v3	normal;
	float	scale;
	int		size;

	size = 512;
	scale = 10.0f;
	normal.x = get_bump(h, size, 1, 1) - get_bump(h, size, -1, 1);
	normal.x += 2.0f * (get_bump(h, size, 1, 0) - get_bump(h, size, -1, 0));
	normal.x += get_bump(h, size, 1, -1) - get_bump(h, size, -1, -1);
	normal.x = scale * -normal.x;
	normal.y = get_bump(h, size, 1, 1) - get_bump(h, size, 1, -1);
	normal.y += 2.0f * (get_bump(h, size, 0, 1) - get_bump(h, size, 0, -1));
	normal.y += get_bump(h, size, -1, 1) - get_bump(h, size, -1, -1);
	normal.y = scale * -normal.y;
	normal.z = 1.0f;
	normal = v3norm(normal);
	return (normal);
}