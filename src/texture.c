/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   texture.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abossel <abossel@student.42bangkok.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/11 12:48:41 by abossel           #+#    #+#             */
/*   Updated: 2023/01/13 20:57:23 by abossel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
#include "raytrace.h"
#include "vector3.h"

/*
 * check if a point is on a black checkerboard square
 * only for shapes that have texture coordinates
 */
int	checkerboard_black(t_hit *h, float scale)
{
	if ((fmodf(h->u * scale, 1.0f) > 0.5f)
		^ (fmodf(h->v * scale, 1.0f) > 0.5f))
		return (1);
	return (0);
}

/*
 * calculate the perlin noise with multiple octaves
 */
float	perlin(float x, float y, float z, int octaves)
{
    float	frequency;
    float	amplitude;
	float	persistence;
    float	sum;
    float	max;

	sum = 0.0f;
	frequency = 1.0f;
	amplitude = 1.0f;
	persistence = 0.5f;
	max = 0.0f;
    while (octaves--)
	{
        sum += noise(x * frequency, y * frequency, z * frequency) * amplitude;
        max += amplitude;
		amplitude *= persistence;
        frequency *= 2.0f;
    }
    return (sum / max);
}

/*
 * map the perlin noise on a torus
 * c is the radius from centre to middle of tube
 * a is radius of the tube
 */
float	perlin_tiling(float x, float y, int octaves)
{
	float	c;
	float	a;
	float	xt;
	float	yt;
	float	zt;

	c = 4.0f;
	a = 1.0f;
	xt = (c + a * cos(2.0f * M_PI * y)) * cos(2.0f * M_PI * x);
	yt = (c + a * cos(2.0f * M_PI * y)) * sin(2.0f * M_PI * x);
	zt = a * sin(2.0f * M_PI * y);
	return (perlin(xt, yt, zt, octaves));
}

/*
 * returns a bump generated by a perlin noise function
 * returns the noise dx, dy units away in a size x size map
 */
float	get_bump(t_hit *h, int size, int dx, int dy)
{
	float	map_u;
	float	map_v;
	int		map_x;
	int		map_y;

	map_x = h->u * size + dx;
	map_y = h->v * size + dy;
	if (map_x < 0)
		map_x = 0;
	if (map_x >= size)
		map_x = size - 1;
	if (map_y < 0)
		map_y = 0;
	if (map_y >= size)
		map_y = size - 1;
	map_u = (float)map_x / size;
	map_v = (float)map_y / size;
	return (perlin_tiling(map_u, map_v, 3));
}

/*
 * returns the bump map normal using a Sobel filter
 * assume a 1024x1024 pixel bump map
 * set scale to adjust height of bumps
 */
t_v3	bumpmap_normal(t_hit *h)
{
	t_v3	normal;
	float	scale;
	int		size;

	size = 1024;
	scale = 10.0f;
	normal.x = get_bump(h, size, 1, 1) - get_bump(h, size, -1, 1);
	normal.x += 2.0f * (get_bump(h, size, 1, 0) - get_bump(h, size, -1, 0));
	normal.x += get_bump(h, size, 1, -1) - get_bump(h, size, -1, -1);
	normal.x = scale * -normal.x;
	normal.y = get_bump(h, size, 1, 1) - get_bump(h, size, 1, -1);
	normal.y += 2.0f * (get_bump(h, size, 0, 1) - get_bump(h, size, 0, -1));
	normal.y += get_bump(h, size, -1, 1) - get_bump(h, size, -1, -1);
	normal.y = scale * -normal.y;
	normal.z = 1.0f;
	normal = v3norm(normal);
	return (normal);
}